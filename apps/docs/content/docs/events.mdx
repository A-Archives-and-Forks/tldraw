---
title: Events
status: published
author: steveruizok
date: 6/22/2023
order: 5
keywords:
  - ui
  - app
  - editor
  - control
  - select
---

The `Editor` class receives events from the user interface via its `dispatch` method. When the `Editor` receives an event, it is first handled internally to update `editor.inputs` and other state before, and then sent into to the editor's state chart.

You shouldn't need to use the `dispatch` method directly, however you may write code in the state chart that responds to these events.

## State Chart

The `Editor` class has a "state chart", or a tree of `StateNode` instances, that contain the logic for the editor's tools such as the select tool or the draw tool. User interactions such as moving the cursor will produce different changes to the state depending on which nodes are active.

Each node be active or inactive. Each state node may also have zero or more children. When a state is active, and if the state has children, one (and only one) of its children must also be active. When a state node receives an event from its parent, it has the opportunity to handle the event before passing the event to its active child. The node can handle an event in any way: it can ignore the event, update records in the store, or run a _transition_ that changes which states nodes are active.

When a user interaction is sent to the editor via its `dispatch` method, this event is sent to the editor's root state node (`editor.root`) and passed then down through the chart's active states until either it reaches a leaf node or until one of those nodes produces a transaction.

<Image title="Events" src="/images/api/events.png" alt="A diagram showing an event being sent to the editor and handled in the state chart." title="The editor passes an event into the state start where it is handled by each active state in order."/>

## Path

You can get the editor's current "path" of active states via `editor.root.path`. In the above example, the value would be `"root.select.idle"`.

You can check whether a path is active via `editor.isIn`, or else check whether multiple paths are active via `editor.isInAny`. 

```ts
editor.store.path // 'root.select.idle'

editor.isIn('root.select') // true
editor.isIn('root.select.idle') // true
editor.isIn('root.select.pointing_shape') // false
editor.isInAny('editor.select.idle', 'editor.select.pointing_shape') // true
```

Note that the paths you pass to `isIn` or `isInAny` can be the full path or a partial of the start of the path. For example, if the full path is `root.select.idle`, then `isIn` would return true for the paths `root`, `root.select`, or `root.select.idle`.

> If all you're interested in is the state below `root`, there is a convenience property, `editor.currentToolId`, that can help with the editor's currently selected tool.

```tsx
import { track, useEditor } from "@tldraw/tldraw"

export const CreatingBubbleToolUi = track(() => {
  const editor = useEditor()

  const isSelected = editor.isIn('root.bubble.creating')

  if (!editor.currentToolId === 'bubble') return
  
  return (
    <div data-isSelected={isSelected}>Creating Bubble</div>
  )
})
```

## Inputs

The editor's `inputs` object holds information about the user's current input state, including their cursor position (in page space _and_ screen space), which keys are pressed, what their multi-click state is, and whether they are dragging, pointing, pinching, and so on.

Note that the modifier keys include a short delay after being released in order to prevent certain errors when modeling interactions. For example, when a user releases the "Shift" key, `editor.inputs.shiftKey` will remain `true` for another 100 milliseconds or so.

This property is stored as regular data. It is not reactive. 